Infinri Application Code Audit Report

This report summarizes a thorough review of the Infinri PHP application (all code under app/). The codebase was analyzed for structure, architecture, coding principles (DRY, KISS, SOLID, etc.), redundancies/dead code, and dependency usage. Key metrics and recommendations are provided below.

Codebase Statistics

Files analyzed: 346 (PHP, JS, XML, Markdown, etc., excluding vendor, node_modules, tests, docs, and static cache files).

Lines of code: ~39,056 total (about 29,081 PHP lines, 3,588 XML, 2,401 JS, 3,986 Markdown).

Classes: ~257 (PHP classes/interfaces).

Functions/methods: ~1,426.

These figures reflect the custom application code under app/ and related directories. (External libraries and autogenerated assets were excluded from the count.)

Dependency Analysis

The project’s composer.json lists many dependencies. We checked actual usage in the code:

Used:

ext-intl, ext-mbstring, ext-pdo_pgsql – Required PHP extensions; used for locale handling, multibyte string support, and PostgreSQL connections (via PDO).

nikic/fast-route – Actively used for HTTP routing (FastRouter, front/controller).

php-di/php-di – Used to build a DI container (ContainerFactory, ObjectManager).

monolog/monolog – Used in the custom logger helper (Core\Helper\Logger).

symfony/cache – Used via a cache pool/factory (Core\Model\Cache\Pool), per CacheInterface.

symfony/console – Used for CLI commands (Core\Console\Command\*).

symfony/event-dispatcher – Used in the event manager (Core\Model\Event\Manager).

symfony/security-core – Used for security features (e.g. AdminUser implements UserInterface).

symfony/security-csrf – Used in CSRF protection (Core\Security\CsrfGuard, middleware, etc.).

vlucas/phpdotenv – Used to load .env (bootstrap.php).

Unused or Redundant:

doctrine/dbal – No references to Doctrine DBAL classes; the app uses raw PDO. Recommendation: Remove if not needed (no code uses it).

ezyang/htmlpurifier – HTML Purifier is used for sanitization (Core\Helper\ContentSanitizer), so this is needed. (Purge any committed cache files instead.)

intervention/image – No code references the Intervention Image library. Recommendation: Remove if image manipulation is not implemented.

respect/validation – Not used anywhere. Recommendation: Remove to streamline.

symfony/password-hasher – No use of Symfony’s password hasher (native PHP password_hash used instead). Recommendation: Remove or replace with built-in if not using Symfony security fully.

symfony/security-http – Not used (no firewall/auth entry points from this component). Recommendation: Remove if no plans to use.

robmorgan/phinx – Used only for database migrations (not in application code). Keep as dev tool if DB migrations are needed, otherwise remove if managed differently.

In summary, several composer packages appear unnecessary. Cleaning these unused dependencies will simplify maintenance.

Architecture & Design

The application follows a modular, component-based MVC architecture with custom frameworks for routing, DI, events, and MVC-like controllers:

Modularity: Code is organized into namespaces/modules: Core, Auth, Admin, Cms, Menu, Seo, Theme, etc. Each covers a distinct area (e.g. CMS, SEO, user auth, etc.). This separation is good for maintainability.

Front Controller / Routing: A single entrypoint (app/bootstrap.php) initializes components (module registry, DI container, etc.) and uses nikic/FastRoute (via Core\App\FastRouter) for HTTP routing. Controllers are invoked based on routes.

Dependency Injection: The project builds a DI container (ContainerFactory) using PHP-DI and XML configs from modules. An ObjectManager wraps the container for global access. Services (e.g. repositories, services) are retrieved from the container or via constructor injection. This decouples components and follows the Dependency Inversion Principle (SOLID).

Event-Observer System: A custom event manager (Core\Model\Event\Manager) wraps Symfony’s EventDispatcher. This supports an observer pattern: modules can observe/handle events without modifying core code (Open/Closed principle). This is a strong design for extensibility.

MVC Patterns: Controllers handle requests and build responses:

Frontend controllers (e.g. Cms\Controller\Index, Core\Controller\Index) typically extend a Core\Controller\AbstractController, using Core\App\Request/Response and rendering layouts.

Admin controllers (e.g. under Admin\Controller\*) similarly handle requests but do not appear to share the same abstract base (they reimplement some request/response logic). (See Recommendations below.)

Models and Repositories: Domain models (e.g. Cms\Model\Page, Menu\Model\Menu) encapsulate data and logic. Resource models handle DB persistence (using PDO). Repositories provide higher-level data access.

Views/Layouts: A simple block/layout system is used (Core\Block\*, Core\Model\Layout\Loader), somewhat analogous to Magento’s MVC. Blocks (containers, text, template) are combined in a layout to generate HTML. CMS pages use template rendering (Cms\Model\View\TemplateResolver).

Configuration: Core and module configuration is loaded from XML files (di-config, routes, events). The Core\Model\Config and readers handle this. This centralizes configs per module.

Overall, the architecture aligns with modern PHP design: modules, DI, event-dispatching, and a lightweight MVC. It avoids a monolithic codebase by splitting concerns.

Coding Principles (DRY, KISS, SOLID)

The code generally follows standard principles, but there are areas to highlight:

DRY (Don't Repeat Yourself): There is good reuse of common logic. For example, abstract controller classes for CMS save/delete actions (Cms\Controller\Adminhtml\AbstractSaveController, AbstractDeleteController) are extended by multiple admin page/block controllers, eliminating duplication. Similarly, Cms\Model\AbstractContentEntity is a base for both Page and Block models. However, some duplication remains: admin controllers do not extend the same base Core\Controller\AbstractController that frontend controllers do, leading to reimplementation of request/response handling in each admin controller. (See Recommendations below.) Overall, code reuse is considered in many places, aligning with DRY
softwareengineering.stackexchange.com
.

KISS (Keep It Simple, Stupid): The code structure is generally straightforward. Classes have clear purposes (e.g. Repository classes handle data, Controllers handle input). However, some complexity arises from the custom frameworks (event system, block/layout engine). Comments and clear naming help understand these. If any complexity is unnecessary (e.g. overly deep inheritance), it should be revisited. In general, the code aims for simplicity, following the “keep it simple” principle
softwareengineering.stackexchange.com
.

SOLID Principles: By design, many SOLID aspects are addressed:

Single Responsibility (SRP): Most classes have a single focus (e.g. a controller, a repository, an observer, etc.). For example, Infinri\Core\Helper\Csrf solely manages CSRF tokens, and Auth\TokenManager handles authentication tokens. This makes classes easier to test and modify.

Open/Closed: The event/observer mechanism and module system allow extending functionality without altering existing code (adhering to Open/Closed). New observers or module setup scripts hook into the system.

Liskov Substitution & Interface Segregation: Interfaces are used (e.g. ModuleSetupInterface, ComponentRegistrarInterface, ObserverInterface, CacheInterface), allowing multiple implementations. Subclasses (e.g. Cms\Page vs. Cms\Block) share abstract bases, following substitutability.

Dependency Inversion: High-level modules depend on abstractions. For instance, controllers depend on repository interfaces, not concrete classes, and the DI container inverts control over instantiation.

Overall, SOLID is applied to ensure the system is maintainable and extensible
softwareengineering.stackexchange.com
. No major SOLID violations were evident, though one should ensure that any classes growing too large are refactored (e.g. breaking up very large controllers or services if they accumulate responsibilities).

Admin vs Frontend Code Reuse

The system distinguishes frontend (public site) from admin (backend UI) but shares common code where appropriate:

Shared Core & Models: Most of the core application framework and data models are shared by both. For example, CMS page/block models and repositories are used by both the public site (to render content) and the admin (to edit content). This centralization prevents duplication.

Abstract Controllers for CMS: In the CMS module, admin page and block save/delete actions extend abstract controllers (AbstractSaveController, AbstractDeleteController) that encapsulate common logic, avoiding repeating code in each controller.

Authentication/Users: There are separate systems for end users and admin users, but they share underlying helpers (e.g. session handling, CSRF protection).

Areas for Improvement: Admin controllers (e.g. Admin\Controller\Users\*, Admin\Controller\System\Config\*) are written similarly to frontend controllers but do not extend a common AbstractController. As a result, request/response handling and layout rendering code is duplicated across admin controllers. Unifying these under a base class (like Core\Controller\AbstractController) would further reduce redundancy. In general, ensure that any logic needed by both admin and frontend is placed in shared base classes or services, with child classes overriding only what differs. This adheres to DRY/KISS principles
softwareengineering.stackexchange.com
.

Redundant or Dead Code

We scanned for potential dead or redundant code:

TODOs/Comments: Some files contain TODO comments indicating incomplete work, e.g. in Core/Block/Template.php, Core/Model/Setup/SchemaSetup.php, Admin/Block/Dashboard.php, Menu/Service/MenuItemResolver.php. These should be addressed or removed to avoid confusion.

Obsolete Assets: The app/Infinri/Core/cache/htmlpurifier/ directory contains HTMLPurifier cache files (likely committed by mistake). These are runtime artifacts and should be cleared from the repository (.gitignore them).

Unused Controllers/Files: No controllers were obviously orphaned, but double-check that all routes correspond to reachable controllers. If any admin “UI components” (XML layout or JS in pub/static) are obsolete, remove them.

Configuration Files: Ensure that config XML/YAML files that no longer apply are cleaned up.

In summary, there was no large “dead code” block found, but housekeeping (removing TODOs, cache files, unused views/scripts) will improve clarity.

Recommendations

Based on the audit, we suggest:

Remove Unused Dependencies: Prune composer.json of unused packages (doctrine/dbal, intervention/image, respect/validation, symfony/password-hasher, symfony/security-http, etc.). This simplifies deployment and avoids unnecessary security maintenance.

Consolidate Controller Base Classes: Have all controllers (admin and frontend) extend a common abstract base (Core\Controller\AbstractController) or a dedicated Admin base. This will eliminate duplicated code (request handling, layout rendering, etc.).

Continue DRY Refactoring: Where similar code appears (e.g. in admin vs frontend), move it into shared services or abstract classes. For example, if admin has custom user logic similar to auth user logic, reuse the same service classes.

Enforce KISS: Avoid overly complex methods. Any large method (50+ lines) should be reviewed for refactoring. For instance, the homepage controller has ~50-line content-generation code; consider moving that into a view/template or builder class if it grows.

Apply SOLID Thoroughly: Ensure each class has a single responsibility. If a class starts to do multiple tasks, extract the extra functionality. For example, if a model begins handling presentation, separate those concerns. Utilize interfaces to decouple (already done in several places).

Clean Up TODOs and Artifacts: Remove or implement the TODOs found in the code. Remove cache files (HTMLPurifier, static generated CSS/JS) from version control.

Document Architecture: Provide or update documentation (comments, READMEs) for custom frameworks (routing, DI configs, event system) so that new developers understand how to add modules or observers without guessing.

Implementing these recommendations will improve maintainability, reduce redundancy, and keep the codebase aligned with best practices